worker_processes 1;

events { worker_connections 1024; }

http {
  include       mime.types;
  default_type  application/octet-stream;
  sendfile      on;

  # If you prefer decompressing instead of disabling upstream gzip:
  # load_module "modules/ngx_http_gunzip_module.so";  # already present in many builds
  # gunzip on;    # uncomment if you don't use Accept-Encoding "" below

  map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
  }

  # Normalize X-Ingress-Path header (empty -> empty)
  map $http_x_ingress_path $ingress_header {
    default $http_x_ingress_path;
    ''      '';
  }

  upstream nextjs {
    server 127.0.0.1:3000;
    keepalive 64;
  }

  server {
    listen 8080;
    allow  172.30.32.2;
    deny   all;

    # Single rule that accepts both ingress-prefixed and plain requests.
    # Uses numbered captures so it's compatible with more nginx builds.
    location ~ ^(/api/hassio_ingress/[^/]+)?(?:/(.*))?$ {
      # Set captured parts into variables
      set $ing $1;
      set $path $2;

      # Upstream URI should be just the remainder of the path (or /)
      set $upstream_uri /$path;

      # Prefer X-Ingress-Path header if present; otherwise fall back to captured ingress ($ing)
      set $prefix $ingress_header;
      if ($prefix = "") {
        set $prefix $ing;
      }

      # Add leading slash when prefix does not already start with one
      if ($prefix ~ ^[^/]) {
        set $prefix /$prefix;
      }

      # Optionally still pass the header (some apps read it)
      proxy_set_header X-Forwarded-Prefix $prefix;

      # Ensure upstream sends *plain* (not gzip/br/zstd) so sub_filter can rewrite
      proxy_set_header Accept-Encoding "";

      add_header X-Debug-Prefix $prefix always;

      # Let sub_filter run on many body types while we verify
      sub_filter_once off;
      sub_filter_types text/html text/css text/javascript application/javascript application/json;

      # Replace occurrences of /_next with the configured prefix + /_next
      # Specific patterns first, then catch-alls to avoid double-prefixing
      sub_filter '/_next/data/'           '$prefix/_next/data/';
      sub_filter '/_next/static/'         '$prefix/_next/static/';
      sub_filter '/_next/image'           '$prefix/_next/image';
      sub_filter '/_next/'                '$prefix/_next/';
      sub_filter 'href="/_next/'          'href="$prefix/_next/';
      sub_filter 'src="/_next/'           'src="$prefix/_next/';
      sub_filter 'content="/_next/'       'content="$prefix/_next/';

      # favicon / manifest
      sub_filter 'href="/favicon'         'href="$prefix/favicon';
      sub_filter 'href="/manifest'        'href="$prefix/manifest';

      # Generic root asset catch-alls (put after specifics to avoid double-prefixing)
      sub_filter 'href="/'                'href="$prefix/';
      sub_filter 'src="/'                 'src="$prefix/';

      # API URL rewrites:
      # - quoted strings used by axios: "/api/...", '/api/...', `/api/...`
      # - generic /api/ catch-all inside JS
      sub_filter '"/api/'                 '"$prefix/api/';
      sub_filter "'/api/"                 "'$prefix/api/";
      sub_filter "`/api/"                 "`$prefix/api/";
      sub_filter '/api/'                  '$prefix/api/';

      # Proxy headers and upstream
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      proxy_pass http://nextjs$upstream_uri;
    }

    # (No separate fallback; the single location above matches all requests.)
  }
}
